# leetCode


## leetCode3 无重复字符的最长子串  
滑动窗口，遇到相同的窗口大小调整

## leetCode4 寻找两个正序数组的中位数
合并两个链表
分区法 分成左右两边相等区域

## leetCode5 最长回文子串
1 中心扩散法， 扩展方法（取的值，i-1, j），遍历
2 马拉车 ， 插入“#”, 扩展函数，结果列表

## leetCode6 Z 字形变换
1 合并 num-1 次上 和 下


## leetCode7 整数反转
1 

## leetCode8  字符串转换整数 (atoi)
1 parseInt 2 自动机


## leetCode9  回文数
1 二分比较 2 翻转再比较


## leetCode11 盛最多水的容器
1 双指针法 通过 while(i<j) 谁小谁动


## leetCode12 整数转罗马数字
1 暴力强转 对照表

## leetCode13 罗马数字转整数  
1 对应表 大的数字在后面是 减，反正 加

## leetCode14 最长公共前缀
1 第一次和第二次比，拿共同的和第三次比。 2 js.sort()整理以后，比较第一个和最后一个

## leetCode15 三数之和题解
1 排序 2 双指针 3 去重 两个地方，遍历点去重，双指针的地方去重。

## leetCode16 最接近的三数之和
1 和三数之和相似， sum>target sum<target, 注意点是要去绝对值去判断距离


## leetCode18  四数之和
1 在三数的基础上增加一次 for循环
2 去重 if(index > 0 && nums[index] == nums[index-1]) break;  
3 if (j - 1 > index && nums[j] === nums[j - 1]) break;

## leetCode19 删除链表的倒数第N个节点
1 双指针 两个指针的距离为N， 一趟遍历完

## leetCode20 有效的括号
1 堆栈  左括号进栈 右括号出栈， 判断出栈的左右是否相等 2 非偶数个优化速度 3 判断最后栈是否为空

## leetCode24 两两交换链表中的节点
1 第1个节点指向第 3 个节点，并从第3个节点开始递归
2 第2个节点指向第 1 个节点


## leetCode29 两数相除
1 二分法
2 被除数不断的相加与除数相减，利用递归
3 注意边界

## leetCode32 最长有效括号
1 堆栈， 2 先放进一个-1， 栈里面放下标


## leetCode33 搜索旋转排序数
1 二分查找法，2 =号的判断

## leetCode34 在排序数组中查找元素的第一个和最后一个位置
1 二分查找法 2 =号的判断，在 >= 0 的时候

## leetCode36 有效的数独
1 用三个数组分别判断 行 列 盒子的有效性 2 盒子的有效性 Math.floor(i/3) * 3 + Math.floor(j/3);

